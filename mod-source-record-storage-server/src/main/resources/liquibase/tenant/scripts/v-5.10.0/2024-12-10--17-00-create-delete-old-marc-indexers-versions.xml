<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.0.xsd">


  <changeSet id="2024-12-10--17-00-update-function-insert_marc_indexers" author="Volodymyr_Rohach">
    <sql splitStatements="false">
      create or replace function ${database.defaultSchemaName}.insert_marc_indexers()
      returns trigger
      as
      $insert_marc_indexers$
      declare
      result integer;
      begin
          if (TG_OP = 'INSERT') then
              insert into ${database.defaultSchemaName}.marc_records_tracking(marc_id, version, is_dirty) values (NEW.id, 0, false);
      result = 0;
          elsif (TG_OP = 'UPDATE') then
      update ${database.defaultSchemaName}.marc_records_tracking set version = version + 1,
                                                                     is_dirty = true
      where marc_id = NEW.id
        returning version into result;
      delete from ${database.defaultSchemaName}.marc_indexers_leader where marc_id = NEW.id;
      end if;
          perform ${database.defaultSchemaName}.fill_in_marc_indexers(NEW.id, NEW.content, result);
      return NEW;
      end;
      $insert_marc_indexers$ language plpgsql;
    </sql>
  </changeSet>

  <changeSet id="2024-12-10--17-00-create-delete-old-marc-indexers-versions" author="Volodymyr_Rohach">
    <createProcedure>
      CREATE OR REPLACE PROCEDURE ${database.defaultSchemaName}.delete_old_marc_indexers_versions() LANGUAGE plpgsql AS $$
      DECLARE
      rec RECORD;
      formatted_value varchar(3);
      exists_flag BOOLEAN;
      partition_name TEXT;
      BEGIN
  CREATE TEMP TABLE IF NOT EXISTS temp_field_nos (field_no varchar(3));
  CREATE TEMP TABLE IF NOT EXISTS temp_deleted_ids (marc_id UUID);

      FOR i IN 1..999 LOOP
    formatted_value := LPAD(i::TEXT, 3, '0');
    partition_name := 'marc_indexers_' || formatted_value;
      EXECUTE format('SELECT EXISTS (
                      SELECT 1
                      FROM %s mi
                      JOIN marc_records_tracking mrt ON mi.marc_id = mrt.marc_id
                      JOIN old_records_tracking ot ON ot.marc_id = mi.marc_id
                      WHERE mrt.is_dirty = true OR ol.has_been_processed = false
                    )', partition_name) INTO exists_flag;
      IF exists_flag THEN
      INSERT INTO temp_field_nos VALUES (formatted_value);
      END IF;
      END LOOP;

      FOR rec IN SELECT field_no FROM temp_field_nos LOOP
        EXECUTE format('WITH deleted AS (
                      DELETE FROM %I mi
                      USING marc_records_tracking mrt, old_records_tracking ot
                      WHERE mi.marc_id = mrt.marc_id
                        AND mi.field_no = $1
                        AND (mrt.is_dirty = true AND mrt.version > mi.version OR ot.has_been_processed = false)
                        AND ot.marc_id = mi.marc_id
                      RETURNING mi.marc_id
                    )
                    INSERT INTO temp_deleted_ids (marc_id)
                    SELECT marc_id FROM deleted', 'marc_indexers_' || rec.field_no)
    USING rec.field_no;
      END LOOP;
      INSERT INTO ${database.defaultSchemaName}.marc_indexers_deleted_ids (marc_id)
      SELECT DISTINCT marc_id FROM temp_deleted_ids ON CONFLICT (marc_id) DO NOTHING;
      DROP TABLE temp_deleted_ids, temp_field_nos;
      END $$;
    </createProcedure>
  </changeSet>


  <changeSet id="2024-12-10--17-00-create-index-on-is-dirty-true" author="Volodymyr_Rohach">
    <sql>
      CREATE INDEX IF NOT EXISTS idx_marc_records_tracking_dirty_true ON ${database.defaultSchemaName}.marc_records_tracking (is_dirty) WHERE is_dirty = true;
    </sql>
  </changeSet>
</databaseChangeLog>
