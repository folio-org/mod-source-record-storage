<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.0.xsd">

  <changeSet id="2023-02-27--12-00-replace-function-fill_in_marc_indexers" author="okolawole-ebsco">
    <sql splitStatements="false">
      create or replace function ${database.defaultSchemaName}.fill_in_marc_indexers(p_marc_id uuid, p_marc_content jsonb)
          returns void
      as
      $fill_in_marc_indexers$
      declare
          temprow RECORD;
      begin
            -- create temp tables if they don't exist
            create temp table if not exists mi_after
            (
                field_no    varchar(3) not null,
                ind1        varchar(1) not null,
                ind2        varchar(1) not null,
                subfield_no varchar(1) not null,
                value       text,
                marc_id     uuid       not null
            );

            create temp table if not exists mi_before
            (
                field_no    varchar(3) not null,
                ind1        varchar(1) not null,
                ind2        varchar(1) not null,
                subfield_no varchar(1) not null,
                value       text,
                marc_id     uuid       not null
            );

            create temp table if not exists mi_delta
            (
                old_field_no    varchar(3),
                old_ind1        varchar(1),
                old_ind2        varchar(1),
                old_subfield_no varchar(1),
                old_value       text,
                old_marc_id     uuid,
                new_field_no    varchar(3),
                new_ind1        varchar(1),
                new_ind2        varchar(1),
                new_subfield_no varchar(1),
                new_value       text,
                new_marc_id     uuid
            );

            -- save current state of indexers
              insert into mi_before (field_no, ind1, ind2, subfield_no, value, marc_id)
              select field_no, ind1, ind2, subfield_no, value, marc_id
              from marc_indexers
              where marc_id = p_marc_id;

          -- save new state of indexers
          insert into mi_after (field_no, ind1, ind2, subfield_no, value, marc_id)
              (with vals as (select value from jsonb_array_elements((
                                 select value
                                 from jsonb_each(p_marc_content) x
                                 where key = 'fields')) y),
                    fields as (select x.key as field_no, x.value as field_value
                               from vals,
                                    jsonb_each(vals.value) x),
                    fields_subfields as (
                        select field_no,
                               trim(field_value ->> 'ind1'::text) ind1,
                               trim(field_value ->> 'ind2')       ind2,
                               field_value -> 'subfields'         subfields,
                               field_value                   from fields),
                    marc_raw as (
                        select fs.field_no, fs.ind1, fs.ind2, fs.field_value, null::text subfield_no, null::text subfield_value
                        from fields_subfields fs
                        where subfields is null
                        union all
                        select fs.field_no, fs.ind1, fs.ind2, fs.field_value, subfs.key::text subfield_no, subfs.value::text subfield_value
                        from fields_subfields fs,
                             jsonb_array_elements(fs.subfields) sx,
                             jsonb_each(sx.value) subfs
                        where subfields is not null),
                    marc as (
                        select m.field_no,
                               CASE WHEN ind1 IS NULL or ind1 = '' THEN '#' ELSE ind1 END
                                 as ind1,
                               CASE WHEN ind2 IS NULL or ind2 = '' THEN '#' ELSE ind2 END
                                 as ind2,
                               CASE WHEN subfield_no IS NULL or trim(subfield_no) = '' THEN '0' ELSE subfield_no END
                        as subfield_no,
                               trim(both '"' from coalesce(subfield_value, field_value::text))
                            as value
                        from marc_raw m)
               select distinct lower(field_no) field_no, ind1, ind2, subfield_no, value, p_marc_id marc_id from marc);

              -- generate diffs
              insert into mi_delta
              select old.*, new.*
              from mi_before old
                       full outer join mi_after new
                                       on old.field_no = new.field_no
                                           and old.ind1 = new.ind1
                                           and old.ind2 = new.ind2
                                           and old.subfield_no = old.subfield_no
                                           and old.value = new.value
                                           and old.marc_id = new.marc_id
              where new.marc_id is null
                 or old.marc_id is null;

              -- perform deletes on marc_indexers table
              for temprow in (select old_field_no, old_ind1, old_ind2, old_subfield_no, old_value, old_marc_id
                            from mi_delta
                            where new_marc_id is null)
                loop
                    -- using a loop so that query plan can be targeted to specific partitions
                delete
                from marc_indexers mi
                where mi.field_no = temprow.old_field_no
                  and mi.ind1 = temprow.old_ind1
                  and mi.ind2 = temprow.old_ind2
                  and mi.subfield_no = temprow.old_subfield_no
                  and mi.value = temprow.old_value
                  and mi.marc_id = temprow.old_marc_id;
              end loop;

            -- insert into marc_indexers
              insert into marc_indexers
              select new_field_no, new_ind1, new_ind2, new_subfield_no, new_value, new_marc_id
              from mi_delta
              where old_marc_id is null;

              -- clear work tables
              truncate table mi_before;
              truncate table mi_after;
              truncate table mi_delta;


      --------------------
      -- LEADER DATA
      --------------------
      insert into ${database.defaultSchemaName}.marc_indexers_leader(p_00_04, p_05, p_06, p_07, p_08, p_09, p_10, p_11, p_12_16, p_17,p_18, p_19, p_20, p_21, p_22, marc_id)
              (select substring(value from 1 for 5)  p_00_04,
                      substring(value from 6 for 1)  p_05,
                      substring(value from 7 for 1)  p_06,
                      substring(value from 8 for 1)  p_07,
                      substring(value from 9 for 1)  p_08,
                      substring(value from 10 for 1) p_09,
                      substring(value from 11 for 1) p_10,
                      substring(value from 12 for 1) p_11,
                      substring(value from 13 for 5) p_12_16,
                      substring(value from 18 for 1) p_17,
                      substring(value from 19 for 1) p_18,
                      substring(value from 20 for 1) p_19,
                      substring(value from 21 for 1) p_20,
                      substring(value from 22 for 1) p_21,
                      substring(value from 23 for 1) p_22,
                      marc_id
                from (select replace(lower(trim(both '"' from value::text)), ' ', '#') as value,
                               p_marc_id marc_id
                      from jsonb_each(p_marc_content) x
                        where key = 'leader') y);
      end;
      $fill_in_marc_indexers$ language plpgsql;
    </sql>
  </changeSet>

  <changeSet id="2023-02-27--12-00-replace-function-insert_marc_indexers" author="okolawole-ebsco">
    <sql splitStatements="false">
      create or replace function ${database.defaultSchemaName}.insert_marc_indexers()
          returns trigger
      as
      $insert_marc_indexers$
      begin
          if (TG_OP = 'UPDATE') then
              delete from ${database.defaultSchemaName}.marc_indexers_leader where marc_id = NEW.id;
          end if;
          perform ${database.defaultSchemaName}.fill_in_marc_indexers(NEW.id, NEW.content);
          return NEW;
      end;
      $insert_marc_indexers$ language plpgsql;
    </sql>
  </changeSet>

  <changeSet id="2021-02-13--12-30-drop-and-create-triggers" author="okolawole-ebsco" runOnChange="true">
    <sql splitStatements="false">
      drop trigger if exists process_marc_records_lb_insert_update_trigger on ${database.defaultSchemaName}.marc_records_lb;
      create trigger process_marc_records_lb_insert_update_trigger after insert or update on ${database.defaultSchemaName}.marc_records_lb for each row execute procedure ${database.defaultSchemaName}.insert_marc_indexers();
    </sql>
  </changeSet>

</databaseChangeLog>
