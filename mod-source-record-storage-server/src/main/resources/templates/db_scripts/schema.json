{
  "tables": [
    {
      "tableName": "snapshots",
      "fromModuleVersion": "mod-source-record-storage-3.1.0",
      "withMetadata": true,
      "withAuditing": false,
      "uniqueIndex": [
        {
          "fieldName": "jobExecutionId",
          "tOps": "ADD"
        }
      ],
      "index": [
        {
          "fieldName": "jobExecutionId",
          "tOps": "ADD"
        }
      ]
    },
    {
      "tableName": "raw_records",
      "fromModuleVersion": "mod-source-record-storage-3.1.0",
      "withMetadata": true,
      "withAuditing": false,
      "uniqueIndex": [
        {
          "fieldName": "id",
          "tOps": "ADD"
        }
      ]
    },
    {
      "tableName": "marc_records",
      "fromModuleVersion": "mod-source-record-storage-3.1.0",
      "withMetadata": true,
      "withAuditing": false,
      "uniqueIndex": [
        {
          "fieldName": "id",
          "tOps": "ADD"
        }
      ]
    },
    {
      "tableName": "error_records",
      "fromModuleVersion": "mod-source-record-storage-3.1.0",
      "withMetadata": true,
      "withAuditing": false,
      "uniqueIndex": [
        {
          "fieldName": "id",
          "tOps": "ADD"
        }
      ]
    },
    {
      "tableName": "records",
      "fromModuleVersion": "mod-source-record-storage-3.1.0",
      "withMetadata": true,
      "withAuditing": false,
      "uniqueIndex": [
        {
          "fieldName": "id",
          "tOps": "ADD"
        }
      ],
      "foreignKeys": [
        {
          "fieldName": "jobExecutionId",
          "targetTable": "snapshots",
          "tOps": "ADD"
        }
      ]
    }
  ],
  "scripts": [
    {
      "run": "after",
      "snippet": "DROP FUNCTION IF EXISTS get_records; CREATE OR REPLACE FUNCTION get_records(query_filter text, order_by text, limitVal int, offsetVal int, schema_name text)  RETURNS TABLE (id uuid, jsonb json, totalrows bigint) AS $$ BEGIN RETURN query EXECUTE format(' SELECT records.id, json_build_object(''id'', records.jsonb->>''id'', ''snapshotId'', records.jsonb->>''snapshotId'', ''matchedProfileId'', records.jsonb->>''matchedProfileId'', ''matchedId'', records.jsonb->>''matchedId'', ''generation'', (records.jsonb->>''generation'')::integer, ''recordType'', records.jsonb->>''recordType'', ''deleted'', records.jsonb->>''deleted'', ''order'', (records.jsonb->>''order'')::integer, ''externalIdsHolder'', records.jsonb->''externalIdsHolder'', ''additionalInfo'', records.jsonb->''additionalInfo'', ''metadata'', records.jsonb->''metadata'', ''rawRecord'', raw_records.jsonb, ''parsedRecord'', COALESCE(marc_records.jsonb), ''errorRecord'', error_records.jsonb) AS jsonb, (SELECT COUNT(id) FROM %s.records %s) AS totalrows FROM %s.records JOIN %s.raw_records ON records.jsonb->>''rawRecordId'' = raw_records.jsonb->>''id'' LEFT JOIN %s.marc_records ON records.jsonb->>''parsedRecordId'' = marc_records.jsonb->>''id''  LEFT JOIN %s.error_records ON records.jsonb->>''errorRecordId'' = error_records.jsonb->>''id''  %s %s LIMIT %s OFFSET %s', schema_name, query_filter, schema_name, schema_name, schema_name, schema_name, query_filter, order_by, limitVal, offsetVal); END $$ language plpgsql;",
      "fromModuleVersion": "mod-source-record-storage-3.1.0"
    },
    {
      "run": "after",
      "snippet": "DROP FUNCTION IF EXISTS get_record_by_id; ",
      "fromModuleVersion": "mod-source-record-storage-3.2.0"
    },
    {
      "run": "after",
      "snippet": "DROP FUNCTION IF EXISTS get_record_by_matched_id; CREATE OR REPLACE FUNCTION get_record_by_matched_id(record_id uuid) RETURNS json AS $recordDto$ DECLARE recordDto json;BEGIN   SELECT json_build_object('id', records.jsonb->>'id', 'snapshotId', records.jsonb->>'snapshotId', 'matchedProfileId', records.jsonb->>'matchedProfileId', 'matchedId', records.jsonb->>'matchedId', 'generation', (records.jsonb->>'generation')::integer, 'recordType', records.jsonb->>'recordType', 'deleted', records.jsonb->>'deleted', 'order', (records.jsonb->>'order')::integer, 'externalIdsHolder', records.jsonb->'externalIdsHolder', 'additionalInfo', records.jsonb->'additionalInfo', 'metadata', records.jsonb->'metadata', 'state', records.jsonb->'state', 'rawRecord', raw_records.jsonb, 'parsedRecord', COALESCE(marc_records.jsonb), 'errorRecord', error_records.jsonb) AS jsonb INTO recordDto FROM records JOIN raw_records ON records.jsonb->>'rawRecordId' = raw_records.jsonb->>'id' LEFT JOIN marc_records ON records.jsonb->>'parsedRecordId' = marc_records.jsonb->>'id' LEFT JOIN error_records ON records.jsonb->>'errorRecordId' = error_records.jsonb->>'id' WHERE (records.jsonb ->> 'matchedId')::uuid = record_id AND records.jsonb->>'state' = 'ACTUAL'; RETURN recordDto; END; $recordDto$ LANGUAGE plpgsql;",
      "fromModuleVersion": "mod-source-record-storage-3.2.0"
    },
    {
      "run": "after",
      "snippet": "DROP FUNCTION IF EXISTS get_source_records; CREATE OR REPLACE FUNCTION get_source_records(query_filter text, order_by text, limitVal int, offsetVal int, deleted_records text, schema_name text) RETURNS TABLE (id uuid, jsonb json, totalrows bigint) AS $$ BEGIN RETURN query EXECUTE format('SELECT records.id, json_build_object(''recordId'', records.jsonb->>''id'', ''snapshotId'', records.jsonb->>''snapshotId'', ''recordType'', records.jsonb->>''recordType'', ''deleted'', records.jsonb->>''deleted'', ''order'', records.jsonb->>''order'', ''externalIdsHolder'', records.jsonb->''externalIdsHolder'', ''additionalInfo'', records.jsonb->''additionalInfo'', ''metadata'', records.jsonb->''metadata'', ''rawRecord'', raw_records.jsonb, ''parsedRecord'', COALESCE(marc_records.jsonb)) AS jsonb, (SELECT COUNT(id) FROM %s.records WHERE records.jsonb->>''parsedRecordId'' IS NOT NULL AND records.jsonb->>''deleted'' = ''%s'' %s ) AS totalrows FROM %s.records JOIN %s.raw_records ON records.jsonb->>''rawRecordId'' = raw_records.jsonb->>''id'' LEFT JOIN %s.marc_records ON records.jsonb->>''parsedRecordId'' = marc_records.jsonb->>''id'' WHERE records.jsonb->>''parsedRecordId'' IS NOT NULL AND records.jsonb->>''deleted'' = ''%s'' %s %s LIMIT %s OFFSET %s', schema_name, deleted_records, query_filter, schema_name, schema_name, schema_name, deleted_records, query_filter, order_by, limitVal, offsetVal); END $$ language plpgsql;",
      "fromModuleVersion" : "mod-source-record-storage-3.1.0"
    },
    {
      "run": "after",
      "snippet": "DROP FUNCTION IF EXISTS get_source_record_by_id; CREATE OR REPLACE FUNCTION get_source_record_by_id(record_id uuid) RETURNS json AS $sourceRecordDto$ DECLARE sourceRecordDto json; BEGIN SELECT json_build_object('recordId', records.jsonb->>'id', 'snapshotId', records.jsonb->>'snapshotId', 'recordType', records.jsonb->>'recordType', 'deleted', records.jsonb->>'deleted', 'order', (records.jsonb->>'order')::integer, 'externalIdsHolder', records.jsonb->'externalIdsHolder', 'additionalInfo', records.jsonb->'additionalInfo', 'metadata', records.jsonb->'metadata', 'rawRecord', raw_records.jsonb, 'parsedRecord', COALESCE(marc_records.jsonb)) AS jsonb INTO sourceRecordDto FROM records JOIN raw_records ON records.jsonb->>'rawRecordId' = raw_records.jsonb->>'id' LEFT JOIN marc_records ON records.jsonb->>'parsedRecordId' = marc_records.jsonb->>'id' WHERE records.id = record_id AND records.jsonb->>'deleted' = 'false' AND records.jsonb->>'parsedRecordId' IS NOT NULL; RETURN sourceRecordDto; END; $sourceRecordDto$ LANGUAGE plpgsql;",
      "fromModuleVersion": "mod-source-record-storage-3.1.2"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS records_raw_record_id_idx_btree ON records USING BTREE ((jsonb ->> 'rawRecordId'));",
      "fromModuleVersion": "mod-source-record-storage-2.3.0"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS records_parsed_record_id_idx_btree ON records USING BTREE ((jsonb ->> 'parsedRecordId'));",
      "fromModuleVersion": "mod-source-record-storage-2.3.0"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS raw_records_id_idx_btree ON raw_records USING BTREE ((jsonb ->> 'id'));",
      "fromModuleVersion": "mod-source-record-storage-2.3.0"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS marc_records_id_idx_btree ON marc_records USING BTREE ((jsonb ->> 'id'));",
      "fromModuleVersion": "mod-source-record-storage-2.3.0"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS error_records_id_idx_btree ON error_records USING BTREE ((jsonb ->> 'id'));",
      "fromModuleVersion": "mod-source-record-storage-2.3.0"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS records_externalIdsHolder_instanceId_idx_btree ON records USING BTREE ((jsonb -> 'externalIdsHolder' ->> 'instanceId'));"
    },
    {
      "run": "after",
      "snippet": "CREATE OR REPLACE FUNCTION get_highest_generation(matchedId uuid, snapshotId uuid) RETURNS integer AS $generation$ DECLARE generation integer; BEGIN SELECT MAX(records.jsonb ->> 'generation') into generation FROM records INNER JOIN snapshots ON records.jsonb ->> 'snapshotId' = snapshots.jsonb ->> 'jobExecutionId' WHERE (records.jsonb ->> 'matchedId')::uuid = matchedId AND snapshots.jsonb ->> 'status' = 'COMMITTED' AND (snapshots.jsonb -> 'metadata' ->> 'updatedDate')::timestamp with time zone < (SELECT snapshots.jsonb ->> 'processingStartedDate' FROM snapshots WHERE (snapshots.jsonb ->> 'jobExecutionId')::uuid = snapshotId)::timestamp with time zone; RETURN generation; END; $generation$ LANGUAGE plpgsql;",
      "fromModuleVersion": "mod-source-record-storage-2.1.0"
    },
    {
      "run": "after",
      "snippet": "CREATE OR REPLACE FUNCTION get_record_by_external_id(externalId uuid, idFieldName text) RETURNS jsonb AS $recordDtoByExternalId$ DECLARE recordDtoByExternalId jsonb; BEGIN SELECT json_build_object('id', recordsByExternalId.jsonb->>'id', 'snapshotId', recordsByExternalId.jsonb->>'snapshotId', 'matchedProfileId', recordsByExternalId.jsonb->>'matchedProfileId', 'matchedId', recordsByExternalId.jsonb->>'matchedId', 'generation', recordsByExternalId.jsonb->>'generation', 'recordType', recordsByExternalId.jsonb->>'recordType', 'deleted', recordsByExternalId.jsonb->>'deleted', 'externalIdsHolder', recordsByExternalId.jsonb->'externalIdsHolder', 'additionalInfo', recordsByExternalId.jsonb->'additionalInfo', 'metadata', recordsByExternalId.jsonb->'metadata', 'rawRecord', raw_records.jsonb, 'parsedRecord', COALESCE(marc_records.jsonb), 'errorRecord', error_records.jsonb) INTO recordDtoByExternalId FROM (SELECT rcd.* FROM (SELECT rc.*, max(generation) over (partition by matchedId) max_generation FROM (SELECT r.*, (r.jsonb ->> 'matchedId')::text  matchedId, (r.jsonb ->> 'generation')::text generation FROM records r WHERE (jsonb -> 'externalIdsHolder' ->> idFieldName)::uuid = externalId) rc) rcd WHERE generation = max_generation) recordsByExternalId JOIN raw_records ON recordsByExternalId.jsonb ->> 'rawRecordId' = raw_records.jsonb ->> 'id' LEFT JOIN marc_records ON recordsByExternalId.jsonb ->> 'parsedRecordId' = marc_records.jsonb ->> 'id' LEFT JOIN error_records ON recordsByExternalId.jsonb ->> 'errorRecordId' = error_records.jsonb ->> 'id'; RETURN recordDtoByExternalId; END; $recordDtoByExternalId$ LANGUAGE plpgsql;",
      "fromModuleVersion": "mod-source-record-storage-3.0.1"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS records_snapshot_id_idx_btree ON records USING BTREE ((jsonb ->> 'snapshotId'));",
      "fromModuleVersion": "mod-source-record-storage-2.7.0"
    },
    {
      "run": "after",
      "snippet": "CREATE INDEX IF NOT EXISTS records_matched_id_and_state_idx_btree ON records USING BTREE ((jsonb ->> 'matchedId'), (jsonb ->> 'state'));",
      "fromModuleVersion": "mod-source-record-storage-3.2.0"
    },
    {
      "run": "after",
      "snippetPath": "migration_scripts/rename_pk_columns.sql",
      "fromModuleVersion": "mod-source-record-storage-3.1.0"
    },
    {
      "run": "after",
      "snippetPath": "migration_scripts/records_external_ids_holder.sql",
      "fromModuleVersion": "mod-source-record-storage-3.0.0"
    },
    {
      "run": "after",
      "snippetPath": "migration_scripts/remove_deprecated_indexes.sql",
      "fromModuleVersion": "mod-source-record-storage-3.1.3"
    }
  ]
}
